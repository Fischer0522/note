# Leetcode每日一题

## 2022

### 4/13:O(1) 时间插入、删除和获取随机元素

[380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

此题说需要在O(1)的时间复杂度内完成插入删除和随机的，因此很容易想到使用哈希表来解决问问题。

使用哈希表能够很容易的解决删除和插入是判断是否存在的问题，但是只使用一个哈希表依旧难以满足我们的需求：

- Map为获取数值时为通过key来获取value的方式
  - 如果key为索引，value为值，虽然插入时刻意通过containsValue方法来进行是否存在的判断，但是在删除时无法通过值来找到对应的key-value进行删除
  - 如果key为值，value为索引，那么无法在O(1)的时间复杂度下获取到randomvalue
- 使用Set的情况与key为值，value为索引的情况类似

综上，我们需要借助其他数据结构

使用Map来绑定值和索引之间的关系，由于删除时传入的为值，因此设置key为值，value为对应的索引

使用一个List来存储具体的值，用于获取随机值

代码如下：

```java
class RandomizedSet {
    Map<Integer,Integer> map;//绑定索引和值的关系
    List<Integer> nums;//存储具体的值
    Random random;//获取随机数
    public RandomizedSet() {
        map=new HashMap<>();
        nums=new LinkedList<>();
        random=new Random();
      
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){
            return false;
        }else{
            //插入时总是插入到末尾位置
            index = nums.size();
            map.put(val,index);
            nums.add(val);
            return true;
        }
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){
            return false;
        }else{
            
            int in=map.get(val);//获取索引
            int last=nums.get(nums.size()-1);//在中间位置删除时，为了不对map进行大规模的改动，将末尾的最后一个数填补到被删除的位置处，如果要删除的为队尾元素本身，那么这一步不起作用
            nums.set(in,last);
            nums.remove(nums.size()-1);//删除已经被挪走的末尾元素
            //put和remove的顺序不可改变，如果要删除的为队尾元素本身，即last和val为同一个元素，那么顺序如果颠倒会导致先删除后又把其重新添加进去，
            map.put(last,in);
            map.remove(val);
            return true;
        }

    }
    
    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);

    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

### 4/15: 迷你语法分析器

[385. 迷你语法分析器](https://leetcode-cn.com/problems/mini-parser/)

此题的最终目标为将一个字符串转化为NestedInteger对象，NestedInteger对象可以如List对象一样进行嵌套，最终的目标就为将含有嵌套List的String正确转换为Nested Integer。

根据题目中的对NestedInteger的定义，我们需要进行的操作主要为初始化和add，通过add传入一个NestedInteger可以在同一层级下往后面追加数字。

对于层级关系的处理，我们选择使用栈来进行操作：

- 首先在栈中初始化一个NestedInteger为最外层
- 如果是在同一层进行追加，那么只需要取出栈顶的NestedInteger，调用add在后面进行追加
- 如果是嵌套新的一层，那么就重新向栈中push一个，后面对新的一层的操作即为对栈顶元素的操作，在这一层完全处理完之后，将这一层作为一个元素放入最初的一层（有点类似于回溯）
- 最后返回的只有一个NestedInteger对象，因此保持栈中最后只存在一个元素，即为最外层的NestedInteger

```
class Solution {
    public NestedInteger deserialize(String s) {
        if(s.charAt(0) != '['){
            return new NestedInteger(Integer.parseInt(s));
        }
        Deque<NestedInteger> stack=new LinkedList<>();
        int num=0;
        boolean nagetive=false;
        for (int i = 0;i < s.length();i++) {
            char c = s.charAt(i);
            if (c == '-') {
                nagetive = true;//处理负数
            } else if (c == '[') {
                stack.push(new NestedInteger());
            } else if (Character.isDigit(c)) {
                int temp = c - '0';
                num = num * 10 + temp;//如果是数字只需进行计算
            } else if (c == ',' || c== ']') {//结束当前数字或者当前这一层
                if (Character.isDigit(s.charAt(i-1))) {//将数字加入当前层，与]]的叠加情况进行区分
                    if (nagetive) {
                        num *= -1;
                    }
                    stack.peek().add(new NestedInteger(num));
                }
                	//初始化
                    num = 0;
                    nagetive = false;
                    if (c== ']' && stack.size() > 1) {
                    //当前层结束，判断是否有嵌套层，如果有则将嵌套List作为一个元素加入到最外层List中，保证栈中最后只有一个元素
                        NestedInteger merge = stack.pop();
                        stack.peek().add(merge);
                    }
                

            }

        }
        return stack.pop();

    }
}
```

### 4/16:最富有客户的资产总量

[1672. 最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)

白给题，不多做解释

```java
class Solution {
    public int maximumWealth(int[][] accounts) {
        int client=0;
        int money=0;
        for(int i=0;i<accounts.length;i++){
            int count=0;
            for(int j=0;j<accounts[i].length;j++){
                count+=accounts[i][j];
            }
            if(count>money){
                money=count;
                client=i;
            }
        }
        return money;


    }
}
```

stream写法一行解决

```java
return Arrays.stream(accounts).map(Arrays::stream).mapToInt(IntStream::sum).reduce(0, Math::max);
```





### 4/17:最常见的单词

简单模拟对字符串进行分割，按照条件一步步模拟即可

```java
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
            Map<String,Integer> map=new HashMap<>();
        String temp="";
        for(int i=0;i<paragraph.length();i++){
            char c=paragraph.charAt(i);
            if (c == ',' || c == ' ' || c == '.'||c=='!'||c=='\''||c==';'||c=='?') {//判断是否为终止符，进行字符串分割
  
                if(temp!=""){//防止分隔符连续出现(在上一个分隔符之后temp为空，再次遇到分隔符时直接跳过，防止将空字符串加入其中)
                    String low=temp.toLowerCase();
                    int num=map.getOrDefault(low,0);
                    num++;
                    map.put(low,num);//统计数量
                    temp="";//遇到分隔符之后将缓存清空，准备处理下一个单词
                }
            } else {
                temp+=c;
            }
             if(i==paragraph.length()-1&&temp!=""){//处理结束时无分隔符的情况
                String low=temp.toLowerCase();
                int num=map.getOrDefault(low,0);
                num++;
                map.put(low,num);
                temp="";
            }
        }
        int max=0;
        String ans="";
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            String word = entry.getKey();
            boolean flag=true;//查看是否存在于banned的列表当中
            for (String ban : banned) {
                    if(ban.equals(word)){
                        flag=false;
                    }
                }
            if(!flag){
                continue;
            }
            int frequency = entry.getValue();//统计出现次数最多的单词
            if (frequency > max) {
                max= frequency;
                ans = word;
            }
        }
        return ans;

    }
}
```



### 4/18：字典序排序

[386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)

字典序：简单来说就是字母表的顺序，排序时从第一位开始往后比较（平日字符串的排序规则）

将数字按照字典序进行排序，主要有以下几条规则：

- 当前位尽可能小
- 当前位一致时，下一位没有的情况排序优先级更高
- 当前位一致且下一位均存在时，下一位更小的排序优先级更高

因此，可以联想到树的先序遍历，得到的结果符合上面的要求。并且树为第一层为9叉（0不能作为首位），剩余全为10叉的一个树，通过dfs遍历即可，当当前节点超过n时则剪枝停止dfs

```java
class Solution {
   
    List<Integer> list=new LinkedList<>();
    public List<Integer> lexicalOrder(int n) {
        for(int i=1;i<=9;i++){//0不能为首位，因此第一层为九叉树
            list.add(i);
            if(i>=n) break;//超过N则进行剪枝
            dfs(i,n);
        }
        return list;
       
    }
    void dfs(int i,int n){
        int num=i*10;//当前位*10，开始确定下一位
        for(int j=0;j<=9;j++){//中间部分允许0的存在，为十叉树
            if(num+j>n) break;//超过N则进行剪枝
            list.add(num+j);
            dfs(num+j,n);
        }
        return;
    }
   
}

```



### 4/19：字符的最短距离

[821. 字符的最短距离 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)

要找该点离指定字符的最短距离即为左右边的都要考虑，如果一次遍历中想要把两遍都考虑到，则需要再嵌套一次循环，最坏的情况则为$O(n^2)$

因此，不妨分两次遍历，第一次遍历只考虑一边，第二次遍历时综合另一边和第一次遍历得到的结果，取最小值即可

代码如下：

```java
class Solution {
    public int[] shortestToChar(String s, char c) {
        int ids=-100000;
        int[] ans=new int[s.length()];
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==c){
                ids=i;
            }
            ans[i]=Math.abs(i-ids);
        }
         ids=-100000;
        for(int i=s.length()-1;i>=0;i--){
            if(s.charAt(i)==c){
                ids=i;
            }
            ans[i]=Math.min(ans[i],Math.abs(ids-i));
        }
        return ans;

    }
}
```



### 4/20：文件的最长绝对路径

[388. 文件的最长绝对路径 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-absolute-file-path/)

有待后续继续学习

### 4/21

[824. 山羊拉丁文 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/goat-latin/)

字符串模拟题，较为简单，分割单词，在按照要求进行处理，使用StringBuilder类可以轻松解决

```java
class Solution {
    public String ans="";
    public String toGoatLatin(String sentence) {
        int index=1;
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<sentence.length();i++){
            char c =sentence.charAt(i);
            if(c == ' ' || i == sentence.length()-1){//分割单词
                boolean flag = true;
                if (i == sentence.length() - 1 ){
                    sb.append(c);//防止最后一个字符被跳过
                    flag=false;//最后一个字母无需补充空格
                }
                 handle(sb,index,flag);
                sb=new StringBuilder();
                index++;//每分割一个单词索引+1
            }
            else{
            sb.append(c);
            }
            

        }
        return ans;

    }
    public void handle(StringBuilder sb,int index,boolean flag){
        if(sb.charAt(0) == 'a'||sb.charAt(0) == 'e' || sb.charAt(0) == 'i' || sb.charAt(0) == 'o' || sb.charAt(0) == 'u'||
        sb.charAt(0) == 'A'||sb.charAt(0) == 'E' || sb.charAt(0) == 'I' || sb.charAt(0) == 'O' || sb.charAt(0) == 'U'){
            
            sb.append("ma");

        } else {
            char temp=sb.charAt(0);
            sb.deleteCharAt(0);
            sb.append(temp);
            sb.append("ma");

        }
        for(int i=0;i<index;i++){
            sb.append("a");//按索引添加"a"
        }
        if(flag) {
            sb.append(" ");//补充单词之间的空格
        }
        
        ans+=sb.toString();

    }
}
```





