# Leetcode每日一题

## 2022

### 4/13:O(1) 时间插入、删除和获取随机元素

[380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

此题说需要在O(1)的时间复杂度内完成插入删除和随机的，因此很容易想到使用哈希表来解决问问题。

使用哈希表能够很容易的解决删除和插入是判断是否存在的问题，但是只使用一个哈希表依旧难以满足我们的需求：

- Map为获取数值时为通过key来获取value的方式
  - 如果key为索引，value为值，虽然插入时刻意通过containsValue方法来进行是否存在的判断，但是在删除时无法通过值来找到对应的key-value进行删除
  - 如果key为值，value为索引，那么无法在O(1)的时间复杂度下获取到randomvalue
- 使用Set的情况与key为值，value为索引的情况类似

综上，我们需要借助其他数据结构

使用Map来绑定值和索引之间的关系，由于删除时传入的为值，因此设置key为值，value为对应的索引

使用一个List来存储具体的值，用于获取随机值

代码如下：

```java
class RandomizedSet {
    Map<Integer,Integer> map;//绑定索引和值的关系
    List<Integer> nums;//存储具体的值
    Random random;//获取随机数
    public RandomizedSet() {
        map=new HashMap<>();
        nums=new LinkedList<>();
        random=new Random();
      
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){
            return false;
        }else{
            //插入时总是插入到末尾位置
            index = nums.size();
            map.put(val,index);
            nums.add(val);
            return true;
        }
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){
            return false;
        }else{
            
            int in=map.get(val);//获取索引
            int last=nums.get(nums.size()-1);//在中间位置删除时，为了不对map进行大规模的改动，将末尾的最后一个数填补到被删除的位置处，如果要删除的为队尾元素本身，那么这一步不起作用
            nums.set(in,last);
            nums.remove(nums.size()-1);//删除已经被挪走的末尾元素
            //put和remove的顺序不可改变，如果要删除的为队尾元素本身，即last和val为同一个元素，那么顺序如果颠倒会导致先删除后又把其重新添加进去，
            map.put(last,in);
            map.remove(val);
            return true;
        }

    }
    
    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);

    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

### 4/15: 迷你语法分析器

[385. 迷你语法分析器](https://leetcode-cn.com/problems/mini-parser/)

此题的最终目标为将一个字符串转化为NestedInteger对象，NestedInteger对象可以如List对象一样进行嵌套，最终的目标就为将含有嵌套List的String正确转换为Nested Integer。

根据题目中的对NestedInteger的定义，我们需要进行的操作主要为初始化和add，通过add传入一个NestedInteger可以在同一层级下往后面追加数字。

对于层级关系的处理，我们选择使用栈来进行操作：

- 首先在栈中初始化一个NestedInteger为最外层
- 如果是在同一层进行追加，那么只需要取出栈顶的NestedInteger，调用add在后面进行追加
- 如果是嵌套新的一层，那么就重新向栈中push一个，后面对新的一层的操作即为对栈顶元素的操作，在这一层完全处理完之后，将这一层作为一个元素放入最初的一层（有点类似于回溯）
- 最后返回的只有一个NestedInteger对象，因此保持栈中最后只存在一个元素，即为最外层的NestedInteger

```
class Solution {
    public NestedInteger deserialize(String s) {
        if(s.charAt(0) != '['){
            return new NestedInteger(Integer.parseInt(s));
        }
        Deque<NestedInteger> stack=new LinkedList<>();
        int num=0;
        boolean nagetive=false;
        for (int i = 0;i < s.length();i++) {
            char c = s.charAt(i);
            if (c == '-') {
                nagetive = true;//处理负数
            } else if (c == '[') {
                stack.push(new NestedInteger());
            } else if (Character.isDigit(c)) {
                int temp = c - '0';
                num = num * 10 + temp;//如果是数字只需进行计算
            } else if (c == ',' || c== ']') {//结束当前数字或者当前这一层
                if (Character.isDigit(s.charAt(i-1))) {//将数字加入当前层，与]]的叠加情况进行区分
                    if (nagetive) {
                        num *= -1;
                    }
                    stack.peek().add(new NestedInteger(num));
                }
                	//初始化
                    num = 0;
                    nagetive = false;
                    if (c== ']' && stack.size() > 1) {
                    //当前层结束，判断是否有嵌套层，如果有则将嵌套List作为一个元素加入到最外层List中，保证栈中最后只有一个元素
                        NestedInteger merge = stack.pop();
                        stack.peek().add(merge);
                    }
                

            }

        }
        return stack.pop();

    }
}
```

