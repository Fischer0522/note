# 索引



作用：避免全表遍历，提高查询效率

本质：B+树，每多添加一个索引就多一棵B+树（InnoDB中）

**常见模型** 

- 哈希表：适合等值查询，由于其无序性，区间查询仍需遍历

- 有序数组：等值查询和范围查询都性能优秀，插入时移动数组，适用于静态存储引擎

- 二叉搜索树：查询和更新的复杂度都为O(log(N))(保持树的平衡)
  - 问题：二叉导致树过高 磁盘IO开销大
  - 解决方案：使用N叉树，一次读取多个数据和后续节点

## InnoDB中的索引

**索引模型** 

B+树，一个索引对应着一棵B+树

M阶B+树特点：

- 每个结点至多有m个子女

- 树内部节点只作为树的索引使用，只有叶子节点才存放数据，并且相邻的叶子节点按关键字大小排序并且通过指针相连

- 相比一般的二叉搜索树更加矮胖

![img](%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98.assets/16555383241952.png)

- 主键索引：存放整行数据

- 非主键索引(二级索引)：存放主键的值(涉及到回表和覆盖索引)

![img](%E7%B4%A2%E5%BC%95%E4%B8%93%E9%A2%98.assets/16555383241931.png)

1. **覆盖索引** ：对于普通索引或者联合索引，如果查询的目标被索引锁覆盖，无需回表

1. **最左前缀** ：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符 

1. **联合索引** ：根据创建联合索引的顺序，以最左原则进行where检索(a,b,c)可以使用 a,(a,b),(a,b,c)进行检索，单独的c不会使用索引

1. **索引下推** ：使用联合索引时，在使用左侧索引进行判断时，同时可以过滤掉后面不满足条件的数据行，减少回表次数

## 优化器的索引选择

查询时索引由优化器进行选择，大多数情况能选择正确

判断标准：扫描的行数(通过基数进行估算)，使用临时表，是否排序(借助索引本身的有序性)，同时还有回表所带来的代价

**基数** ：

- 概念：一个索引上不同的值的个数

- 基数越大，区分度越好

- 计算方式：抽样统计

```SQL
select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
```

解决方案：

- Force index强制选择索引

- 修改查询语句进行引导

## 字符串字段索引

由于MYSQL支持前缀索引，故可以选择字符串的一部分来创建索引

- 优点：索引占用的空间更小

- 缺点：
  - 增加匹配次数（前缀部分相同，需要到主键索引上获取完整信息，多次比较）
  - 无法使用索引覆盖

使用前缀索引时应关注区分度，确定一个可以接受的损失比例，适当截取

**其他处理方式** 

- 如身份证，学号等前几位高度重合的字段，可以选择使用倒叙存储，使用后面区分度的即为作为前缀索引，则查询时：

```SQL
mysql> select field_list from t where id_card = reverse('input_id_card_string')')
```

- hash字段：在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。此时只需要四个字节