# 操作系统

## 内存管理

### 抽象：地址空间

操作系统为程序提供一个物理内存的抽象，叫做**地址空间**，运行的程序感受不到这个虚拟化的过程，作为程序员，我们所操作和感知到的内存也并非真实的物理内存，因此程序的地址总是从0开始

一个地址空间包含一个程序需要的所有的内存状态，主要包括以下三个区域：

- 代码区：存储程序运行的代码

- 堆区：动态分配的内存，由用户手动管理，如malloc或者new分配的内存

- 栈区：保存函数的调用信息，分配空间给局部变量，函数返回值等，由操作系统自动管理

在地址空间中，程序代码和堆位于地址的低位，并且分配时由低位向高位进行分配，栈位于地址的高位，分配时从高位向低位分配，中间的为未分配区域，留给栈和堆进行增长

在由地址空间向物理地址的映射过程当中，主要解决的就是如何合理分配空间，使中间的未分配的区域尽可能小的占用实际物理内存

### 机制：地址转换

将指令中的虚拟地址转换到数据实际存储的地址，有点类似内存的寻址过程

**动态重定位(基于硬件)** 

实现重定位CPU需要两个寄存器，基址寄存器和限制寄存器

基址寄存器用于存放起始位置，虚拟地址的位置加上基址寄存器中的值即可得到真实的物理地址

界限寄存器确保这个地址在进程地址的空间范围内，在虚拟地址与基址寄存器求和前就进行检查，如果超过了这个界限，或者为负数时，则会引发异常

1. 创建进程时，操作系统在物理内存空间中找到一个能够容纳当前位置，并且将其标记为已用
2. 进程终止时，对当前进程所占用的内存空间进行释放，归还为空闲列表，清除当前区域的相关数据结构，比如说一个记录着当前空间大小和下一个空间位置的结构体
3. 上下文切换时，由于CPU只有一个基址寄存器和界限寄存器，因此对于不同进程之间的切换，应当保存当前寄存器中的内容到每个进程都有的结构当中，如PCB等，供上一个进程以后使用，并且将当前进程的值加载进寄存器当中。在移动地址空间时，操作系统会把新的地址空间重新更新到寄存器当中

### 分段

分段主要用于解决的就是栈和堆之间的一大块空域区域的问题。

在代码块，栈，堆这种模型下，将其分为三个段，每个段设置一对基址寄存器和界限寄存器，在进行地址映射时，分别将这三个段映射到物理地址当中

在进行映射的过程当中，由于段在虚拟地址中的起始位置不再是0，因此在进行地址映射时，应当考虑虚拟地址中段本身的偏移量，比如：

一个数据在虚拟地址中的地址为4200，而段的起始地址为4096，因此考虑段在虚拟地址中的偏移量，真正进行映射的地址(转换为段起始从0开始的地址)即为4200-4096=104，将104加上基址寄存器中的值得到的才为真正的物理地址，如果不考虑段的偏移量/起始地址，那么则与为分段无异，失去分段的意义

**段的引用**

用前几位表示段号，后几位为段内的偏移量，类似于cache的块号和块内寻址，在界限检查时，只需要将段内偏移量与界限寄存器进行比较即可

如一个14位的地址，前两位的表示段号，那么则为00-03四个段，后12位为段内偏移量

**栈的反向增长**

为了解决栈的反向增长，在段寄存器中新加一位是否进行反向增长用于区分，反向增长则为反向偏移

**共享**

部分内存可以共享给不同进程使用，但是为了防止不同进程之间的相互影响，在段寄存器当中对段加上保护位，来标识读写权限，代码段的权限位可读可执行那么则可映射到多个虚拟空间，供多个进程使用，但是每个进程又认为自己独占了这个内存

**外部碎片**

不同的段的大小不同，对物理内存空间进行划分切割，导致一些小的空间无法放下任何的段，成为外部碎片

解决方法

- 重新分配，紧凑内存，但是成本很高
- 内存分配算法，成本低，但是无法完全解决问题，总会留下碎片

### 空闲空间管理

主要解决分配过程中的外部碎片的问题

**底层机制**

堆上管理空闲空间的数据结构为空闲链表

分配空间时找到一个合适大小的空间进行分割，一部分分配，剩余的部分保持未分配的空闲状态，同时碎片也就是这么得来的

释放时一是对当前内存空间进行回收，然后对相邻的空间空间进行合并，恢复成大的空间

**实际于内存中**

当将地址分配给用户时，会同时分配一个头块，存储一定的信息，如当前段的大小和一个进行完整性检查的幻数，在对空余块进行分配时，同样会分配一个头块，其中包含着用于标识剩余空间大小的size和下一个段的位置next

分配和释放时，需要对next进行修改，指向新的下一个内存块

**算法策略**

- 最优匹配：遍历空间链表，寻找大小最合适的区域，尽可能小，但是问题时遍历性能损耗高，并且会产生小的碎片
- 最差匹配：遍历，寻找尽可能大的，会产生过量的碎片，实际表现确实是差
- 首次匹配：找到第一个就进行分配，有速度优势
- 下次匹配：相比首次匹配多维护一个指针，每次从上一次分配的结果出继续寻找空间进行分配
- 伙伴系统：分配时对空间不断进行二分，一分为二得到的两个空间称为**伙伴**直至获得一个能够分配的最小空间，释放时检查该空间的伙伴是否为空闲，如果为空闲则将二者合并，获得一个更大的空间，这个过程一直不断向上回溯合并到不能合并为止
